# Some deep thoughts on Clojurific JavaScript

### Some basic design notes
* **Do your best to keep everything as simple as possible, and then compose.** This is lispish, and important. The idea is not to create monoliths with tight integration. In particular, this cuts against the grain of a static typing system. That said, the ordering of the pieces may be important. More on this below.
* **The runtime is important at every stage of design.** Static functional typesystems try to push everything towards the compiler. There's overhead in keeping everything around at runtime, but for learners and REPL-driven-developers, keeping the runtime aware of most everything is important.
* **Speed considerations are to be mitigated, not avoided.** A lot of this is about being fast enough; I have a lot of design work to get from here to where I'm troubleshooting the speed limitations of animation loops. For example, it will be impossible to get JavaScript to use immutable data structures with literal objects & arrays, but you can get a lot of the way towards making pure-functional transformations of those datastructures performant using transducers and generators.
* **Speed considerations can be mitigated throgh runtime manipulations.** One thing worth noting is that much of the speed difficulty in the full environment (especially but not only runtime type checking, as opposed to a much more difficult & complected attempt at static type inference and checking) can be managed through clever (and simple) manipulations of the runtime, including dispatch to different versions of a function based on environment variables.
* **First things first.** Interestingly, the static type system impulse leads you to try to get the type system right first. The lispish approach, however, actually leads to a different set of foundations: the manipulation of functions. I have discovered in the few days I've been working on this that function manipulation and good error handling are at the absolute core. (The good error handling is, of course, my own consideration.)
* **Polymorphism is important.** Runtime polymorphic dispatch is slow, but it also ends up being a primary design consideration here. Because JS's polymorphic dispatch system is a damn mess of special cases and inconsistent abstractions, and it requires the use of methods, we have to bootstrap our own scheme. This will take quite a lot of time to get right. I believe the best approach (for now) will be to mimic Clojure's multimethods; protocols will be harder.
* **Use the host platform's polymorphic dispatch system.** It's likely faster than anything I can invent myself. cf. Rich Hickey's "History of Clojure," where part of the desideratum of the host system is fast runtime polymorphic dispatch.
* **Much of what is done in Clojure with macros can be accomplished using function composition.** This is not so surprising, but instead of manipulating code-as-data, we can use functions to get a lot of the way there. (It's frequently not as performant, but: meh.)
* **Simplicity is key to building out a core.** Clojure has a great many small, specific functions. (To wit: consider many different versions of function composition.) This may be difficult for a beginner to master, but it's worth developing the ergonomics of beginner interaction only once the environment is fully built out.
* **Where possible, mirror the semantics of Clojure.** The pattern I'm anticipating, ultimately, is a compiler which (this is stupid, but bear with me) compiles Ludus (which is JavaScript) into ClojureScript, which then recompiles into JavaScript. The idea here is that parts of Clojure(Script) are very close to the semantics of Logo, and, similarly, parts of JavaScript can also be made to get close. But Clojure(Script) has the advantage of having fast immutable data structures, very good optimization on other fronts, and a library ecosystem that is mostly purely functional (so, for example, I may not need to rely on p5.js but rather on cljs canvas libraries). It may not be necessary, ultimately (more on that later), but it's a good goal to have in mind while building out the JS environment.
* **Do some careful research.** The ACM histories of Logo and Clojure will be very useful in this regard. In place of experimentation & play as design work (what I've been doing for the past couple of years), there's a moment here to get pretty rigorous about the language design. Those are the places to start.
* **When in doubt, use plain old data structures and functions.** 
