# Types, namespaces, & modules

Finally, at long last, I believe I have created a sufficient type system for Ludus. It is both simple and easy (amazing!), and fully structural, not nominal. I'm sure there are limitations, but none of them seem obvious for the time being. The system includes:
* Limited but judicious use of JS's prototypical inheritance. We're using a version of my little portable `create` function that takes a prototype as the first parameter; and a `deftype` function that creates a prototype. It's possible `deftype` can also take a `struct` to validate the properties on the object, although that's perhaps better handled by the `create` function.
* Lamination of the prototype to a namespace. Basically, the idea is that a namespace definition will include not only the name and a space, but also the possibility of a `type` field, which will do nothing other than add the namespace to the `ns` field on the prototype. That means that any function bundled in a namespace with a type, across Ludus, can be accessed using `.ns.{method}`. And, because namespaces throw errors when you try to access their properties, you'll get a useful error like `dissoc` not defined for type `Array`.
* A standardized type field. The other thing registering a type with `ns` will do is install the type itself in the `t` field of the namespace. That means the prototype of any given object will be available as `{obj}.ns.t`.
* All Ludus types will actually have this available to them, excepting `undefined`, where (a) we really don't need it, and (b) we hit limitations of JS. That means that, effectively, some methods in the `core` namespace will do polymorphic dispatch to corresponding functions in the namespace associated with a particular type.
* This does mean, in namespaces associated with types, declaring the type near the top of the namespace and including it in the namespace at the bottom. It also means that namespaces can only be associated with a single type, which seems fair.
* This also means that type dispatch relies on a contract for function signatures being standardized. That's true of any dynamic language; at least in Ludus you'll get an error if you get the contract wrong.
* One thing that's worth noting is that, while using prototypes, this scheme does *not* make use of `this`, except for in cases where it's absolutely necessary--and those are constrained to the `Type` prototype.
* Unless I start using a symbol for `ns` (which could be a thing?), the only drawback with this scheme is that it relies on manipulating builtin prototypes with string keys. I don't hate it, but it's so clear to me that it's bad practice that I need to bargain with myself that the namespace should install itself as `ns` vs. `Symbol.for('ludus/ns')`.
* It seems plausible for there to be a sort of `method` call that automates something like `let conj = (coll, item, ...items) => coll.ns.conj(coll, item, ...items);`. Clojure would use `(.conj ...)`. Ludus doesn't have that luxury. Automating it, though, requires string names, which, while all over Ludus and normalized within it, might feel less ergonomic. One variation: `let conj = (coll, item) => get(Symbol.for('ludus/ns').conj(coll, item);`. Slightly more verbose, but that, at least, doesn't violate any Ludus rules (excepting `Symbol.for`, which maybe needs some version without the dot in the middle...)
* It's easy enough to have a predicate that goes like, `let implements = (coll, method) => method in coll.ns;`, which will simply say "anything that has the `method`." But this doesn't seem necessary to start, because trying to access, say, `Math.conj` will throw an error that says that `conj` isn't defined in namespace `Math`, along with an `error found while calling function conj on (4, 'foo')` report. Which seems fairly useful.
* The one problem is this appears to leave builtin objects closed for extension, and we want them open. We want folks to be able to define new methods on, say, an array--especially since new methods won't fuck with state (or probably won't). It's easy enough to manipulate the namespace by using `def`; although that's probably bad practice, modulating the namespace directly. But adding methods to types _is_ a form of stateful environmental manipulation, so why is it bad to mutate? Shared mutable global state! But moving it from an ns to a secondary item doesn't actually fix the problem, other than making a function newly available *in* a namespace, as a function. What would be wrong with that? What I need is a separate `methods` situation that acts as a secondary namespace whose functions aren't directly accessible in the namespace but nevertheless show up accessing things as methods. That's not hard, I don't think, but it may not be very graceful. Probably that isn't a decision I need to make now? (I am not good at deferring such decisions.)
* This does not let us introspect the interfaces a type implements, because there is no nominal typing here. I think that's probably okay? It does make it actually trivial to define new types. I'll need to get into the guts of `unsigned/env`.
* One thought I have is about restrictions on exports. I think it should be possible to impose two restrictions on modules at the parser level:
  - Exports must either be in the form of `export {foo, bar, baz};` or `export default ns({...});`. Both can coexist in the same file, although normal practice is to use namespaces. 
  - No inline exports of the form `export let foo = ...`.
  - Only `ns`es may be `export default`ed. This usefully means that you can't accidentally get `undefined` as an export.
  - You may not define an `ns` without `export default`ing it.
