# On performance
I've worked up a flocking stress test in Kredati, and even with typechecking and error handling turned off, it's not pretty. There are a few issues:
1. Defining functions is expensive because the `Object.defineProperty` calls for renaming things is very slow (why?). In particular, creating a `seq` is expensive because it calls `once`, which renames the function it returns. All of this is very sane, but it is perhaps worth it to introduce a fast version of `once` internal to the `seq` module, since knowing the name is not important. And, the effectively nested loops in Flocking means that we keep doing that. Optimization is frequently about managing these edge cases, but I'm not sure how far I'm going to get there. There are also calls to `partial` in the stack that also make this slow. I can set up an environment variable that turns off "pretty-printing" for functions, but that will only get me so far.
2. There are a million and one calls to `match_arity`, which means that while each call is fast, it adds up.
3. `get` is also slow compared to direct property access.
4. These three calls together come out to more than 37% of each frame in Chrome's profiler. #1 is tractable, but #s 2 and 3 are pretty baked into Ludus at this point: variadic functions are very baked in (and a solution with `partial` or `p` for short seems like a kludge), and computed property access (like renaming things) is just slow in JS, and using `get` will just be slow. The way we'd rewrite `get("foo")` without computed property access is `(x) => x.foo`, which isn't so bad, but also isn't great. I'd love to avoid lambdas everywhere.
5. The question is whether the Flocking stress test is enough to worry about. It's possible to fix the `match_arity` problem by including a compiler pass and rewriting a `foo` with arities 2 and 3 as `foo$2` and `foo$3`, which I believe is what cljs does. But if I'm including a compiler pass, then we should just ditch JS and write a new language (which is mentally what I'm doing already).