# `Lazy::ns`
Jump to: [Namespaces](#Namespaces), [Functions](#Functions), [Values](#Values)


## Namespaces

## Functions
#### `cycle::fn`
`(seqable)::(is_coll)`<br/>
`(size, seqable)::(or<is_int,is_infinity>, is_coll)`<br/>
Creates a lazy, possibly infinite, sequence of values created by cycling through the members of a sequence. E.g., `cycle([1, 2, 3]); //=> 1, 2, 3, 1, 2, 3, 1, 2, ...`. With two arguments, the first argument specifies how many times to execute the cycle.

#### `gen::fn`
`(init, step, done)::(is_any, is_fn, is_fn)`<br/>
`(init, step, done, map)::(is_any, is_fn, is_fn, is_fn)`<br/>
Creates a generator. It takes an `init`ial value, two or three unary functions: `step`, `done`, and, optionally, `map`. `step` should return the series of values, first by taking the `init` value, and then, the previous value. `done` should return `true` once the generator should terminate. `map` is optionally applied to the value before it is yielded into the generator. It is useful if your generator needs to keep track of state that is more complex than the values you wish to appear in the generator.

#### `interleave::fn`
`(...seqables)`<br/>
Given a list of seqables, produce a `seq` that is generated by taking the first element of each, then the second, until one of them is empty. E.g., `inteleave([1, 2], 'ab'); //=> Seq( 1, a, 2, b )`.

#### `lazy::fn`
`(init, step, done)::(is_any, is_fn, is_fn)`<br/>
`(init, step, done, map)::(is_any, is_fn, is_fn, is_fn)`<br/>
Creates a lazy, possibly infinite, sequence. It takes an `init`ial value, two or three unary functions: `step`, `done`, and, optionally, `map`. `step` should return the series of values, first by taking the `init` value, and then, the previous value. `done` should return `true` once the sequence should terminate. `map` is optionally applied to the value before it is yielded into the sequence. It is useful if your lazy sequence needs to keep track of state that is more complex than the values you wish to appear in the sequence.

#### `range::fn`
`(max)::(is_int)`<br/>
`(start, max)::(is_int, is_int)`<br/>
`(start, max, step)::(is_int, is_int, is_int)`<br/>
Creates a sequence of numbers, in order. With one argument, it counts up from 0 to the maximum (exclusive) in steps of +1. With two arguments, it counts up from the start to the max in steps of +1. With three, it counts up to max from start, in steps of whatever you give it.

#### `repeat::fn`
`(value)::(is_any)`<br/>
`(count, value)::(or<is_int,is_infinity>, is_any)`<br/>
Produces a possibly infinite `seq` that is just the same value, repeated over and over again. With two arguments, the first is the number of times to repeate `value`. E.g., `repeat(4, 'foo'); //=> Seq( 'foo', 'foo', 'foo', 'foo' )`.

#### `repeatedly::fn`
`(fn)::(is_fn)`<br/>
`(count, fn)::(or<is_int,is_infinity>, is_fn)`<br/>
Takes a nullary function, presumably with side effects, and calls that function over and over again. With one argument, it will call the fucntion infinitely. With two, it will call the function `count` times.

## Values
